"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAttestationPacked = void 0;
const convertCOSEtoPKCS_1 = require("../../helpers/convertCOSEtoPKCS");
const convertCertBufferToPEM_1 = require("../../helpers/convertCertBufferToPEM");
const validateCertificatePath_1 = require("../../helpers/validateCertificatePath");
const getCertificateInfo_1 = require("../../helpers/getCertificateInfo");
const verifySignature_1 = require("../../helpers/verifySignature");
const metadataService_1 = require("../../services/metadataService");
const verifyAttestationWithMetadata_1 = require("../../metadata/verifyAttestationWithMetadata");
/**
 * Verify an attestation response with fmt 'packed'
 */
async function verifyAttestationPacked(options) {
    const { attStmt, clientDataHash, authData, credentialPublicKey, aaguid, rootCertificates } = options;
    const { sig, x5c, alg } = attStmt;
    if (!sig) {
        throw new Error('No attestation signature provided in attestation statement (Packed)');
    }
    if (typeof alg !== 'number') {
        throw new Error(`Attestation Statement alg "${alg}" is not a number (Packed)`);
    }
    const signatureBase = Buffer.concat([authData, clientDataHash]);
    let verified = false;
    if (x5c) {
        const { subject, basicConstraintsCA, version, notBefore, notAfter } = (0, getCertificateInfo_1.getCertificateInfo)(x5c[0]);
        const { OU, CN, O, C } = subject;
        if (OU !== 'Authenticator Attestation') {
            throw new Error('Certificate OU was not "Authenticator Attestation" (Packed|Full)');
        }
        if (!CN) {
            throw new Error('Certificate CN was empty (Packed|Full)');
        }
        if (!O) {
            throw new Error('Certificate O was empty (Packed|Full)');
        }
        if (!C || C.length !== 2) {
            throw new Error('Certificate C was not two-character ISO 3166 code (Packed|Full)');
        }
        if (basicConstraintsCA) {
            throw new Error('Certificate basic constraints CA was not `false` (Packed|Full)');
        }
        if (version !== 2) {
            throw new Error('Certificate version was not `3` (ASN.1 value of 2) (Packed|Full)');
        }
        let now = new Date();
        if (notBefore > now) {
            throw new Error(`Certificate not good before "${notBefore.toString()}" (Packed|Full)`);
        }
        now = new Date();
        if (notAfter < now) {
            throw new Error(`Certificate not good after "${notAfter.toString()}" (Packed|Full)`);
        }
        // TODO: If certificate contains id-fido-gen-ce-aaguid(1.3.6.1.4.1.45724.1.1.4) extension, check
        // that itâ€™s value is set to the same AAGUID as in authData.
        // If available, validate attestation alg and x5c with info in the metadata statement
        const statement = await metadataService_1.MetadataService.getStatement(aaguid);
        if (statement) {
            // The presence of x5c means this is a full attestation. Check to see if attestationTypes
            // includes packed attestations.
            if (statement.attestationTypes.indexOf('basic_full') < 0) {
                throw new Error('Metadata does not indicate support for full attestations (Packed|Full)');
            }
            try {
                await (0, verifyAttestationWithMetadata_1.verifyAttestationWithMetadata)({
                    statement,
                    credentialPublicKey,
                    x5c,
                    attestationStatementAlg: alg,
                });
            }
            catch (err) {
                const _err = err;
                throw new Error(`${_err.message} (Packed|Full)`);
            }
        }
        else {
            try {
                // Try validating the certificate path using the root certificates set via SettingsService
                await (0, validateCertificatePath_1.validateCertificatePath)(x5c.map(convertCertBufferToPEM_1.convertCertBufferToPEM), rootCertificates);
            }
            catch (err) {
                const _err = err;
                throw new Error(`${_err.message} (Packed|Full)`);
            }
        }
        verified = await (0, verifySignature_1.verifySignature)({
            signature: sig,
            signatureBase,
            leafCert: x5c[0],
        });
    }
    else {
        const hashAlg = convertCOSEtoPKCS_1.COSEALGHASH[alg];
        verified = await (0, verifySignature_1.verifySignature)({
            signature: sig,
            signatureBase,
            credentialPublicKey,
            hashAlgorithm: hashAlg
        });
    }
    return verified;
}
exports.verifyAttestationPacked = verifyAttestationPacked;
//# sourceMappingURL=verifyAttestationPacked.js.map