"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verifyAuthenticationResponse = void 0;
const base64url_1 = __importDefault(require("base64url"));
const decodeClientDataJSON_1 = require("../helpers/decodeClientDataJSON");
const toHash_1 = require("../helpers/toHash");
const verifySignature_1 = require("../helpers/verifySignature");
const parseAuthenticatorData_1 = require("../helpers/parseAuthenticatorData");
const isBase64URLString_1 = require("../helpers/isBase64URLString");
const parseBackupFlags_1 = require("../helpers/parseBackupFlags");
/**
 * Verify that the user has legitimately completed the login process
 *
 * **Options:**
 *
 * @param credential Authenticator credential returned by browser's `startAssertion()`
 * @param expectedChallenge The base64url-encoded `options.challenge` returned by
 * `generateAssertionOptions()`
 * @param expectedOrigin Website URL (or array of URLs) that the registration should have occurred on
 * @param expectedRPID RP ID (or array of IDs) that was specified in the registration options
 * @param authenticator An internal {@link AuthenticatorDevice} matching the credential's ID
 * @param requireUserVerification (Optional) Enforce user verification by the authenticator
 * (via PIN, fingerprint, etc...)
 * @param advancedFIDOConfig (Optional) Options for satisfying more stringent FIDO RP feature
 * requirements
 * @param advancedFIDOConfig.userVerification (Optional) Enable alternative rules for evaluating the
 * User Presence and User Verified flags in authenticator data: UV (and UP) flags are optional
 * unless this value is `"required"`
 */
async function verifyAuthenticationResponse(options) {
    const { credential, expectedChallenge, expectedOrigin, expectedRPID, authenticator, requireUserVerification, advancedFIDOConfig, } = options;
    const { id, rawId, type: credentialType, response } = credential;
    // Ensure credential specified an ID
    if (!id) {
        throw new Error('Missing credential ID');
    }
    // Ensure ID is base64url-encoded
    if (id !== rawId) {
        throw new Error('Credential ID was not base64url-encoded');
    }
    // Make sure credential type is public-key
    if (credentialType !== 'public-key') {
        throw new Error(`Unexpected credential type ${credentialType}, expected "public-key"`);
    }
    if (!response) {
        throw new Error('Credential missing response');
    }
    if (typeof (response === null || response === void 0 ? void 0 : response.clientDataJSON) !== 'string') {
        throw new Error('Credential response clientDataJSON was not a string');
    }
    const clientDataJSON = (0, decodeClientDataJSON_1.decodeClientDataJSON)(response.clientDataJSON);
    const { type, origin, challenge, tokenBinding } = clientDataJSON;
    // Make sure we're handling an authentication
    if (type !== 'webauthn.get') {
        throw new Error(`Unexpected authentication response type: ${type}`);
    }
    // Ensure the device provided the challenge we gave it
    if (typeof expectedChallenge === 'function') {
        if (!expectedChallenge(challenge)) {
            throw new Error(`Custom challenge verifier returned false for registration response challenge "${challenge}"`);
        }
    }
    else if (challenge !== expectedChallenge) {
        throw new Error(`Unexpected authentication response challenge "${challenge}", expected "${expectedChallenge}"`);
    }
    // Check that the origin is our site
    if (Array.isArray(expectedOrigin)) {
        if (!expectedOrigin.includes(origin)) {
            const joinedExpectedOrigin = expectedOrigin.join(', ');
            throw new Error(`Unexpected authentication response origin "${origin}", expected one of: ${joinedExpectedOrigin}`);
        }
    }
    else {
        if (origin !== expectedOrigin) {
            throw new Error(`Unexpected authentication response origin "${origin}", expected "${expectedOrigin}"`);
        }
    }
    if (!(0, isBase64URLString_1.isBase64URLString)(response.authenticatorData)) {
        throw new Error('Credential response authenticatorData was not a base64url string');
    }
    if (!(0, isBase64URLString_1.isBase64URLString)(response.signature)) {
        throw new Error('Credential response signature was not a base64url string');
    }
    if (response.userHandle && typeof response.userHandle !== 'string') {
        throw new Error('Credential response userHandle was not a string');
    }
    if (tokenBinding) {
        if (typeof tokenBinding !== 'object') {
            throw new Error('ClientDataJSON tokenBinding was not an object');
        }
        if (['present', 'supported', 'notSupported'].indexOf(tokenBinding.status) < 0) {
            throw new Error(`Unexpected tokenBinding status ${tokenBinding.status}`);
        }
    }
    const authDataBuffer = base64url_1.default.toBuffer(response.authenticatorData);
    const parsedAuthData = (0, parseAuthenticatorData_1.parseAuthenticatorData)(authDataBuffer);
    const { rpIdHash, flags, counter, extensionsData } = parsedAuthData;
    // Make sure the response's RP ID is ours
    if (typeof expectedRPID === 'string') {
        const expectedRPIDHash = (0, toHash_1.toHash)(Buffer.from(expectedRPID, 'ascii'));
        if (!rpIdHash.equals(expectedRPIDHash)) {
            throw new Error(`Unexpected RP ID hash`);
        }
    }
    else {
        // Go through each expected RP ID and try to find one that matches
        const foundMatch = expectedRPID.some(expected => {
            const expectedRPIDHash = (0, toHash_1.toHash)(Buffer.from(expected, 'ascii'));
            return rpIdHash.equals(expectedRPIDHash);
        });
        if (!foundMatch) {
            throw new Error(`Unexpected RP ID hash`);
        }
    }
    if (advancedFIDOConfig !== undefined) {
        const { userVerification: fidoUserVerification } = advancedFIDOConfig;
        /**
         * Use FIDO Conformance-defined rules for verifying UP and UV flags
         */
        if (fidoUserVerification === 'required') {
            // Require `flags.uv` be true (implies `flags.up` is true)
            if (!flags.uv) {
                throw new Error('User verification required, but user could not be verified');
            }
        }
        else if (fidoUserVerification === 'preferred' || fidoUserVerification === 'discouraged') {
            // Ignore `flags.uv`
        }
    }
    else {
        /**
         * Use WebAuthn spec-defined rules for verifying UP and UV flags
         */
        // WebAuthn only requires the user presence flag be true
        if (!flags.up) {
            throw new Error('User not present during authentication');
        }
        // Enforce user verification if required
        if (requireUserVerification && !flags.uv) {
            throw new Error('User verification required, but user could not be verified');
        }
    }
    const clientDataHash = (0, toHash_1.toHash)(base64url_1.default.toBuffer(response.clientDataJSON));
    const signatureBase = Buffer.concat([authDataBuffer, clientDataHash]);
    const signature = base64url_1.default.toBuffer(response.signature);
    if ((counter > 0 || authenticator.counter > 0) && counter <= authenticator.counter) {
        // Error out when the counter in the DB is greater than or equal to the counter in the
        // dataStruct. It's related to how the authenticator maintains the number of times its been
        // used for this client. If this happens, then someone's somehow increased the counter
        // on the device without going through this site
        throw new Error(`Response counter value ${counter} was lower than expected ${authenticator.counter}`);
    }
    const { credentialDeviceType, credentialBackedUp } = (0, parseBackupFlags_1.parseBackupFlags)(flags);
    const toReturn = {
        verified: await (0, verifySignature_1.verifySignature)({
            signature,
            signatureBase,
            credentialPublicKey: authenticator.credentialPublicKey,
        }),
        authenticationInfo: {
            newCounter: counter,
            credentialID: authenticator.credentialID,
            userVerified: flags.uv,
            credentialDeviceType,
            credentialBackedUp,
            authenticatorExtensionResults: extensionsData,
        },
    };
    return toReturn;
}
exports.verifyAuthenticationResponse = verifyAuthenticationResponse;
//# sourceMappingURL=verifyAuthenticationResponse.js.map