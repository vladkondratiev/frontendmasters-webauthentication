"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isCertRevoked = void 0;
const jsrsasign_1 = require("jsrsasign");
const node_fetch_1 = __importDefault(require("node-fetch"));
const asn1_schema_1 = require("@peculiar/asn1-schema");
const asn1_x509_1 = require("@peculiar/asn1-x509");
const convertCertBufferToPEM_1 = require("./convertCertBufferToPEM");
const cacheRevokedCerts = {};
/**
 * A method to pull a CRL from a certificate and compare its serial number to the list of revoked
 * certificate serial numbers within the CRL.
 *
 * CRL certificate structure referenced from https://tools.ietf.org/html/rfc5280#page-117
 */
async function isCertRevoked(cert) {
    const certSerialHex = cert.getSerialNumberHex();
    // Check to see if we've got cached info for the cert's CA
    let certAuthKeyID = null;
    try {
        certAuthKeyID = cert.getExtAuthorityKeyIdentifier();
    }
    catch (err) {
        return false;
    }
    if (certAuthKeyID) {
        const cached = cacheRevokedCerts[certAuthKeyID.kid.hex];
        if (cached) {
            const now = new Date();
            // If there's a nextUpdate then make sure we're before it
            if (!cached.nextUpdate || cached.nextUpdate > now) {
                return cached.revokedCerts.indexOf(certSerialHex) >= 0;
            }
        }
    }
    let crlURL = undefined;
    try {
        crlURL = cert.getExtCRLDistributionPointsURI();
    }
    catch (err) {
        // Cert probably didn't include any CDP URIs
        return false;
    }
    // If no URL is provided then we have nothing to check
    if (!crlURL) {
        return false;
    }
    // Download and read the CRL
    const crlCert = new jsrsasign_1.X509();
    try {
        const respCRL = await (0, node_fetch_1.default)(crlURL[0]);
        const dataCRL = await respCRL.buffer();
        const dataPEM = (0, convertCertBufferToPEM_1.convertCertBufferToPEM)(dataCRL);
        crlCert.readCertPEM(dataPEM);
    }
    catch (err) {
        return false;
    }
    const data = asn1_schema_1.AsnParser.parse(Buffer.from(crlCert.hex, 'hex'), asn1_x509_1.CertificateList);
    const newCached = {
        revokedCerts: [],
        nextUpdate: undefined,
    };
    // nextUpdate
    if (data.tbsCertList.nextUpdate) {
        newCached.nextUpdate = data.tbsCertList.nextUpdate.getTime();
    }
    // revokedCertificates
    const revokedCerts = data.tbsCertList.revokedCertificates;
    if (revokedCerts) {
        for (const cert of revokedCerts) {
            const revokedHex = Buffer.from(cert.userCertificate).toString('hex');
            newCached.revokedCerts.push(revokedHex);
        }
        // Cache the results
        if (certAuthKeyID) {
            cacheRevokedCerts[certAuthKeyID.kid.hex] = newCached;
        }
        return newCached.revokedCerts.indexOf(certSerialHex) >= 0;
    }
    return false;
}
exports.isCertRevoked = isCertRevoked;
//# sourceMappingURL=isCertRevoked.js.map